el = column_model.parts['Beam'].elements.getByBoundingCylinder(center1=(b/2-15,(h-tf)/2,0),center2=(b/2-15,(h-tf)/2,40),radius =20)

fl_mesh_a=30
for i in range(4):
	c1=el[0].getElemEdges()[i].getNodes()[0].coordinates
	c2=el[0].getElemEdges()[i].getNodes()[1].coordinates
	d=sqrt((c1[0]-c2[0])**2+(c1[1]-c2[1])**2+(c1[2]-c2[2])**2)
	if d < fl_mesh_a:
		fl_mesh_a = d

el = column_model.parts['Beam'].elements.getByBoundingCylinder(center1=(0,0,0),center2=(0,0,40),radius =30)

wb_mesh_a=30
for i in range(4):
	c1=el[0].getElemEdges()[i].getNodes()[0].coordinates
	c2=el[0].getElemEdges()[i].getNodes()[1].coordinates
	d=sqrt((c1[0]-c2[0])**2+(c1[1]-c2[1])**2+(c1[2]-c2[2])**2)
	if d < wb_mesh_a:
		wb_mesh_a = d

nef=round(b/fl_mesh_a) #no of elements in the width of flange
ned=round((h-2*tf)/wb_mesh_a) #no of elements in the depth of web

for i in range(int(ned)):
	y=-1*((h-tf)/2-wb_mesh_a/2)+i*wb_mesh_a
	el = column_model.parts['Beam'].elements.getByBoundingCylinder(center1=(0,y,0),center2=(0,y,3000),radius =20)
	column_model.parts['Beam'].Set(elements= el, name='W_Set_y='+str(int(y)))
	#here will come the code to populate res stresses

for i in range(int(nef)):
	x=-1*(b/2-fl_mesh_a/2)+i*fl_mesh_a
	el1 = column_model.parts['Beam'].elements.getByBoundingCylinder(center1=(x,(h-tf)/2,0),center2=(x,(h-tf)/2,3000),radius =20)
	el2 = column_model.parts['Beam'].elements.getByBoundingCylinder(center1=(x,-1*(h-tf)/2,0),center2=(x,-1*(h-tf)/2,3000),radius =20)
	column_model.parts['Beam'].Set(elements= el1+el2, name='FL_Set_x='+str(int(x)))
	#here will come the code to populate res stresses